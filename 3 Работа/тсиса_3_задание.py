# -*- coding: utf-8 -*-
"""ТСиСА 3 задание.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oWLqD1L7itHN7m91E8_BTSZI3GDCkNxe

# Заревич Михаил 513-2

## 1. Обобщить мнения экспертов:

### а) ранжирование
"""

import openpyxl
# https://sky.pro/media/kak-ispolzovat-python-dlya-raboty-s-dannymi-excel/
# https://openpyxl.readthedocs.io/en/stable/
# https://www.datacamp.com/community/tutorials/python-excel-tutorial

workbook = openpyxl.load_workbook("/content/TS_variants_Lab_3_1-3.xlsx")
sheet = workbook["TS_variants_Lab_3_1-3"]

# список для хранения мнений экспертов
a = []

# Получаю данные из моего варианта
for row in sheet.iter_rows(min_row=11, max_row=15, values_only=True):
    a.append(row[1])
    print(row[1])


# Мой вариант row in sheet.iter_rows(min_row=11, max_row=15, values_only=True):
# Вариант Сергея for row in sheet.iter_rows(min_row=59, max_row=63, values_only=True):

# преобразование строк в списки
for i in range(len(a)):
    a[i] = a[i].split(">")
    print(a[i])

# Список с переменными.
variables = ["A"+str(i+1) for i in range(len(a[0]))]
print(variables)

# список словарей, созданный с помощью словарного и списочного выражения
# Проходится по каждому подсписку, элементы каждого подсписка заносит в словарь
# в котором ключи - переменные, а значение - место, выставленное экспертом.
f = [{str(a[it][i]): i+1 for i in range(len(a[it]))} for it in range(len(a))]

for i in f:
    print(i)

"""Код для нормальной сортировки строк.
Без неё он будет сортировать как А1 А10 А2
http://nedbatchelder.com/blog/200712/human_sorting.html

https://stackoverflow.com/questions/5967500/how-to-correctly-sort-a-string-with-a-number-inside
"""

# Библиотека для использования регулярных выражений
# сдесь она нам нужна для поиска чисел в строке
import re
# https://skillbox.ru/media/code/regulyarnye-vyrazheniya-v-python-sintaksis-poleznye-funktsii-i-zadachi/
# https://docs.python.org/3/library/re.html


def convert(text):
    """
    Преобразует строку в число, если возможно. иначе возвращает неизменённую строку
    """
    return int(text) if text.isdigit() else text


def natural_keys(string):
    """
    Преобразует строку в список из строк и чисел в ней.

    >>> natural_keys("A10")
    ['A', 10, '']
    Получает на вход кортеж со ключом и значением

    """

    # достаёт ключ из кортежа
    text = string[0]

    # re.split(pattern, string, maxsplit=0, flags=0)
    # Split the source string by the occurrences of the pattern,
    # returning a list containing the resulting substrings.
    return [convert(c) for c in re.split(r'(\d+)', text)]

"""Сортировка словаря по ключам
Это нужно для того, чтобы потом посчитать сумму рангов
"""

# Natural keys возвращает список в котором первое значение - буква, второе - число в виде int
# Если я всё правильно понял, то сортировка происходит следующим образом:
# Сначала сортирует по первым элементам в natural keys, то есть по буквам
# Потом по второму - по числам. Поскольку они в виде int, а не str, как были до этого
# Поэтому они будут сортироваться нормальном порядке, т.е. 1 2 ... 10
for i in range(len(f)):
    f[i] = dict(sorted(f[i].items(), key=natural_keys))

    # через лямбда функцию
    #f[i]= dict(sorted(f[i].items(), key = lambda x:(natural_keys(x))))


for i in f:
    print(i)

"""Поиск суммы рангов"""

# список для хранения значений
# 10 значений для всех 10 переменных
temp = [0 for i in range(len(a[0]))]

count = 0


for i in f:
      count = 0

      # ранг каждой переменной заносит на своё место в список temp
      for value in i.values():
          temp[count] += value
          count +=1


SummaRangov = dict(zip(variables, temp))
print(SummaRangov)

# сортировка словаря по возрастанию значений
SummaRangov = dict(sorted(SummaRangov.items(), key = lambda x:(x[1])))
print(SummaRangov)

"""Поиск дубликатов, т.е. связных рангов"""

from collections import defaultdict

# словарь с дубликатами
Duplicates = defaultdict(list)

for key,value in SummaRangov.items():
    Duplicates[value].append(key)

Duplicates = {key:value for key,value in Duplicates.items() if len(value)>1}

# ключи - повторяющиеся значения в словаре SummaRangov. значения - ключи, с этими значениями
print(Duplicates)

"""Присваивание рангов"""

# Списки с ключами и значениями
keys = list(SummaRangov.keys())
values = list(SummaRangov.values())

count = 1
i = 0

# цикл по элементам списка с ключами
while i < len(keys):

    # Если его значения нет как ключа в списке дубликатов, присваевает этому ключу его ранг
    if values[i] not in Duplicates:
        SummaRangov[keys[i]] = count
        count+=1
        i+=1
        continue

    # Если значение есть как ключ в списке дубликатов
    if values[i] in Duplicates:

        # количество ключей с одинаковыми значениями - длина списка
        length = len(Duplicates[values[i]])

        # каждому ключу, у которых дублируется данное значение, меняет значение на среднее значение присваеваемых им рангов
        for j in Duplicates[values[i]]:
            SummaRangov[j] = (2*count+length-1)/length

        # удаляет просмотренные ключи из словаря
        del Duplicates[values[i]]

        # увеличивает i и count на количество дубликатов, чтобы пропустить их и не заносить им место
        i+=length
        count += length

"""Данные были получены по ранговой шкале обратного порядка. То есть, элемент А4 - самый худший, а А4 - самый лучший"""

print("Обобщённый ранг: ")
print(SummaRangov)

"""### б) парное сравнение

#### Матрицы парных сравнений
"""

# Список из 5 матриц парных сравнений, по 1 матрице для каждого эксперта
# у каждой матрицы размер 10 на 10.
ListOfMatrixes = [[[0 for k in range(len(a[0]))]for j in range(len(a[0]))] for i in range(len(f))]
for i in ListOfMatrixes:
    for j in i:
        print(j)
    print()

"""##### Тест"""

for i in range(len(f)):
    print(f[i])

d1 = {'A1': 9, 'A2': 4, 'A3': 8, 'A4': 2, 'A5': 10, 'A6': 5, 'A7': 1, 'A8': 3, 'A9': 7, 'A10': 6}
#d1 = {'A1': 8, 'A2': 1, 'A3': 5, 'A4': 3, 'A5': 4, 'A6': 9, 'A7': 7, 'A8': 6, 'A9': 10, 'A10': 2}
temp = [0 for i in range(10)]

print(temp)

keys = list(d1.keys())
values = list(d1.values())

print(keys)
print(values)

# сравниваем первый элемент А1 с остальными. его индекс 0
# значение - 2
currentkey = int(keys[0][1:]) #8
currentvalue = values[0] #3
print(currentkey,currentvalue)

for j in range(len(temp)):
    # если значение какого-либо элемента больше текущего, надо поставить 1
    if values[j] >= currentvalue:
        temp[j] = 1
    else:
        temp[j] = 0
print(temp)

"""#### Продолжение"""

for matrix in range(len(ListOfMatrixes)):

      # ранги текущего эксперта(первый эксперт - первая матрица, второй-вторая и т.д.)
      CurrentDict = f[matrix]

      for row in range(len(ListOfMatrixes[matrix])):

          #
          Keys = list(CurrentDict.keys())
          Values = list(CurrentDict.values())


          # текущие ключ и значение. соответствуют номеру столбца
          currentkey = int(Keys[row][1:])
          currentvalue = Values[row]

          for column in range(len(ListOfMatrixes[matrix][row])):
              # если значение элемента матрицы больше значения текущего ключа, заносит 1. иначе 0
              if Values[column]>=currentvalue:
                  ListOfMatrixes[matrix][row][column] = 1
              else:
                  ListOfMatrixes[matrix][row][column] = 0

for i in f:
    print(i)

for i in ListOfMatrixes:
    for j in i:
        print(j)
    print()

"""#### Обобщённая матрица"""

# Обобщённая матрица
A = [[0 for j in range(len(f[0]))] for i in range(len(f[0]))]
for i in A:
    print(i)

# заполнение обобщённой матрицы

# range 1 т.к. по всем матрицам нужно проходиться не в этом цикле
for matrix in range(1):

    for row in range(len(ListOfMatrixes[matrix])):
        for column in range(len(ListOfMatrixes[matrix][row])):

            # счётчики нулей и единиц
            onecount = 0
            zerocount = 0

            # ищет нули и единицы в элементе [row][column] остальных матриц
            for k in range(len(ListOfMatrixes)):
                if ListOfMatrixes[k][row][column] == 1:
                    onecount +=1
                else:
                    zerocount+=1

            if onecount - zerocount >=0:
                A[row][column] = 1
            else:
                A[row][column] = 0

"""Вывод обобщённой матрицы и рангов, полученных с помощью неё"""

for i in A:
    print(i)

print()
ranks = [0 for i in range(len(A))]
for i in range(len(A)):
    for j in range(len(A[i])):
        ranks[i] += A[i][j]
print(ranks)

"""## 2. Обобщить мнения экспертов, полученные непосредственной оценкой по балльной шкале:

### а) без учёта компетентности экспертов,
"""

# мнения экспертов
ranks = []
# компетентность экспертов
coefficients = []

# Получаю данные из моего варианта
for row in sheet.iter_rows(min_row=11, max_row=15, values_only=True):
    ranks.append(list(row[7:17]))
    coefficients.append(float(row[18]))
for i in ranks:
    print(i)
print()
print(coefficients)

# транспонирует матрицу.
# не понимаю, как это работает.
for i in zip(*ranks):
    print(i)

FinalRanksWoCoef = []

for i in zip(*ranks):
    count = 0
    for j in i:
        count+=j

    FinalRanksWoCoef.append(count/5)

print(dict(zip(variables, FinalRanksWoCoef)))

"""### б) с учётом компетентности"""

FinalRanks = []

for i in zip(*ranks):
    count = 0
    for j in range(len(i)):
        count+=i[j]*coefficients[j]

    FinalRanks.append(count)

FinalRanksWCoef = dict(zip(variables, FinalRanks))
print(FinalRanksWCoef)